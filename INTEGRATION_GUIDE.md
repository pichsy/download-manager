# Download Manager - Android å¤šçº¿ç¨‹ä¸‹è½½ç®¡ç†åº“æ¥å…¥æ–‡æ¡£

ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ã€é«˜æ€§èƒ½çš„Androidå¤šçº¿ç¨‹ä¸‹è½½ç®¡ç†åº“ï¼Œæ”¯æŒæ–­ç‚¹ç»­ä¼ ã€ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†ã€ä¼˜å…ˆçº§è°ƒåº¦ç­‰ä¼ä¸šçº§ç‰¹æ€§ã€‚

## ğŸš€ æ ¸å¿ƒç‰¹æ€§

### ğŸ“¥ å¤šçº¿ç¨‹åˆ†ç‰‡ä¸‹è½½
- **æ™ºèƒ½åˆ†ç‰‡ç­–ç•¥**ï¼šæ ¹æ®æ–‡ä»¶å¤§å°è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çº¿ç¨‹æ•°ï¼ˆ1MBä»¥ä¸‹å•çº¿ç¨‹ï¼Œ10MBä»¥ä¸‹2çº¿ç¨‹ï¼Œ100MBä»¥ä¸‹3çº¿ç¨‹ï¼Œ100MBä»¥ä¸Š4çº¿ç¨‹ï¼‰
- **å¹¶å‘ä¸‹è½½**ï¼šå¤šä¸ªåˆ†ç‰‡åŒæ—¶ä¸‹è½½ï¼Œå¤§å¹…æå‡ä¸‹è½½é€Ÿåº¦
- **æ–­ç‚¹ç»­ä¼ **ï¼šæ”¯æŒHTTP Rangeè¯·æ±‚ï¼Œç½‘ç»œä¸­æ–­åå¯ä»æ–­ç‚¹ç»§ç»­ä¸‹è½½
- **æ–‡ä»¶å®Œæ•´æ€§**ï¼šä½¿ç”¨RandomAccessFileç¡®ä¿åˆ†ç‰‡å†™å…¥çš„æ­£ç¡®æ€§

### ğŸ¯ ä»»åŠ¡ç®¡ç†
- **ä¼˜å…ˆçº§è°ƒåº¦**ï¼šæ”¯æŒURGENTã€HIGHã€NORMALã€LOWå››ä¸ªä¼˜å…ˆçº§
- **é˜Ÿåˆ—ç®¡ç†**ï¼šæ™ºèƒ½ä»»åŠ¡é˜Ÿåˆ—ï¼Œæ”¯æŒå¹¶å‘æ§åˆ¶
- **çŠ¶æ€ç®¡ç†**ï¼šWAITINGã€PENDINGã€DOWNLOADINGã€PAUSEDã€COMPLETEDã€FAILEDã€CANCELLEDä¸ƒç§çŠ¶æ€
- **ä»»åŠ¡å»é‡**ï¼šè‡ªåŠ¨æ£€æµ‹é‡å¤ä»»åŠ¡ï¼Œé¿å…é‡å¤ä¸‹è½½

### ğŸ’¾ æ•°æ®æŒä¹…åŒ–
- **Roomæ•°æ®åº“**ï¼šä½¿ç”¨Android Roomè¿›è¡Œæ•°æ®æŒä¹…åŒ–
- **åˆ†ç‰‡ç®¡ç†**ï¼šæ¯ä¸ªä¸‹è½½ä»»åŠ¡çš„åˆ†ç‰‡ä¿¡æ¯ç‹¬ç«‹å­˜å‚¨
- **çŠ¶æ€æ¢å¤**ï¼šåº”ç”¨é‡å¯åè‡ªåŠ¨æ¢å¤å†å²ä»»åŠ¡çŠ¶æ€
- **åŸå­æ“ä½œ**ï¼šç¡®ä¿æ•°æ®ä¸€è‡´æ€§

### ğŸ”„ å“åº”å¼ç›‘å¬
- **Flowç›‘å¬å™¨**ï¼šåŸºäºKotlin Flowçš„å“åº”å¼äº‹ä»¶ç›‘å¬
- **ç”Ÿå‘½å‘¨æœŸç»‘å®š**ï¼šè‡ªåŠ¨ç®¡ç†ç›‘å¬å™¨ç”Ÿå‘½å‘¨æœŸ
- **å®æ—¶è¿›åº¦**ï¼šæ”¯æŒå®æ—¶è¿›åº¦å’Œé€Ÿåº¦æ›´æ–°
- **é˜²æŠ–æœºåˆ¶**ï¼šé¿å…è¿‡äºé¢‘ç¹çš„UIæ›´æ–°

### ğŸ› ï¸ é«˜çº§åŠŸèƒ½
- **å­˜å‚¨ç®¡ç†**ï¼šæ™ºèƒ½å­˜å‚¨ç©ºé—´ç›‘æ§å’Œç®¡ç†
- **ç¼“å­˜ç®¡ç†**ï¼šçƒ­ä»»åŠ¡ç¼“å­˜ï¼Œæå‡æŸ¥è¯¢æ€§èƒ½
- **ä¿ç•™ç­–ç•¥**ï¼šè‡ªåŠ¨æ¸…ç†è¿‡æœŸä»»åŠ¡
- **ç½‘ç»œé€‚é…**ï¼šæ”¯æŒç§»åŠ¨ç½‘ç»œå’ŒWiFiç½‘ç»œæ§åˆ¶

## ğŸ“¦ é¡¹ç›®ç»“æ„

```
download-manager/
â”œâ”€â”€ app/                    # ç¤ºä¾‹åº”ç”¨
â”‚   â”œâ”€â”€ src/main/java/
â”‚   â”‚   â””â”€â”€ com/pichs/download/demo/
â”‚   â”‚       â”œâ”€â”€ MainActivity.kt          # ä¸»ç•Œé¢ç¤ºä¾‹
â”‚   â”‚       â”œâ”€â”€ DownloadManagerActivity.kt # ä¸‹è½½ç®¡ç†ç•Œé¢
â”‚   â”‚       â””â”€â”€ AppDetailActivity.kt     # åº”ç”¨è¯¦æƒ…ç•Œé¢
â”‚   â””â”€â”€ build.gradle.kts
â”œâ”€â”€ base/                   # åŸºç¡€åº“æ¨¡å—
â”‚   â”œâ”€â”€ src/main/java/
â”‚   â”‚   â””â”€â”€ com/pichs/shanhai/base/     # åŸºç¡€å·¥å…·ç±»
â”‚   â””â”€â”€ build.gradle.kts
â”œâ”€â”€ download/               # æ ¸å¿ƒä¸‹è½½åº“æ¨¡å—
â”‚   â”œâ”€â”€ src/main/java/
â”‚   â”‚   â””â”€â”€ com/pichs/download/
â”‚   â”‚       â”œâ”€â”€ core/                   # æ ¸å¿ƒä¸‹è½½å¼•æ“
â”‚   â”‚       â”‚   â”œâ”€â”€ DownloadManager.kt         # ä¸‹è½½ç®¡ç†å™¨
â”‚   â”‚       â”‚   â”œâ”€â”€ MultiThreadDownloadEngine.kt # å¤šçº¿ç¨‹ä¸‹è½½å¼•æ“
â”‚   â”‚       â”‚   â”œâ”€â”€ DownloadRequestBuilder.kt   # è¯·æ±‚æ„å»ºå™¨
â”‚   â”‚       â”‚   â”œâ”€â”€ FlowDownloadListener.kt     # Flowç›‘å¬å™¨
â”‚   â”‚       â”‚   â”œâ”€â”€ AdvancedDownloadQueueDispatcher.kt # é«˜çº§é˜Ÿåˆ—è°ƒåº¦å™¨
â”‚   â”‚       â”‚   â””â”€â”€ DownloadScheduler.kt        # ä¸‹è½½è°ƒåº¦å™¨
â”‚   â”‚       â”œâ”€â”€ model/                  # æ•°æ®æ¨¡å‹
â”‚   â”‚       â”‚   â”œâ”€â”€ DownloadTask.kt            # ä¸‹è½½ä»»åŠ¡æ¨¡å‹
â”‚   â”‚       â”‚   â”œâ”€â”€ DownloadStatus.kt          # ä¸‹è½½çŠ¶æ€æšä¸¾
â”‚   â”‚       â”‚   â”œâ”€â”€ DownloadChunk.kt           # åˆ†ç‰‡æ¨¡å‹
â”‚   â”‚       â”‚   â””â”€â”€ DownloadPriority.kt       # ä¼˜å…ˆçº§æšä¸¾
â”‚   â”‚       â”œâ”€â”€ store/                 # æ•°æ®å­˜å‚¨
â”‚   â”‚       â”‚   â”œâ”€â”€ db/                        # Roomæ•°æ®åº“
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ DownloadDatabase.kt    # æ•°æ®åº“å®šä¹‰
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ DownloadEntity.kt     # ä»»åŠ¡å®ä½“
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ DownloadChunkEntity.kt # åˆ†ç‰‡å®ä½“
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ DownloadDao.kt        # ä»»åŠ¡DAO
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ DownloadChunkDao.kt   # åˆ†ç‰‡DAO
â”‚   â”‚       â”‚   â”œâ”€â”€ TaskRepository.kt         # ä»»åŠ¡ä»“åº“
â”‚   â”‚       â”‚   â””â”€â”€ InMemoryTaskStore.kt      # å†…å­˜ä»»åŠ¡å­˜å‚¨
â”‚   â”‚       â”œâ”€â”€ config/               # é…ç½®ç±»
â”‚   â”‚       â”‚   â””â”€â”€ DownloadConfig.kt         # ä¸‹è½½é…ç½®
â”‚   â”‚       â””â”€â”€ utils/                # å·¥å…·ç±»
â”‚   â”‚           â”œâ”€â”€ OkHttpHelper.kt           # HTTPå·¥å…·
â”‚   â”‚           â”œâ”€â”€ FileUtils.kt              # æ–‡ä»¶å·¥å…·
â”‚   â”‚           â””â”€â”€ DownloadLog.kt            # æ—¥å¿—å·¥å…·
â”‚   â””â”€â”€ build.gradle.kts
â””â”€â”€ build.gradle.kts
```

## ğŸ› ï¸ å¿«é€Ÿå¼€å§‹ - æ¥å…¥æ–‡æ¡£

### ğŸ“‹ ä¾èµ–é…ç½®

åœ¨é¡¹ç›®çš„ `build.gradle.kts` ä¸­æ·»åŠ ä¾èµ–ï¼š

```kotlin
dependencies {
    implementation(project(":download"))
    implementation(project(":base"))
}
```

### ğŸš€ åŸºç¡€æ¥å…¥

#### 1. åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨

åœ¨ `Application` ç±»ä¸­åˆå§‹åŒ–ï¼š

```kotlin
class App : Application() {
    override fun onCreate() {
        super.onCreate()
        // åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨
        DownloadManager.init(this)
        
        // å¯é€‰ï¼šé…ç½®ä¸‹è½½å‚æ•°
        DownloadManager.config {
            maxConcurrentTasks = 3        // æœ€å¤§å¹¶å‘ä¸‹è½½æ•°
            connectTimeoutSec = 60        // è¿æ¥è¶…æ—¶
            readTimeoutSec = 60          // è¯»å–è¶…æ—¶
            writeTimeoutSec = 60         // å†™å…¥è¶…æ—¶
            allowMetered = true          // å…è®¸ç§»åŠ¨ç½‘ç»œä¸‹è½½
            callbackOnMain = true        // å›è°ƒåœ¨ä¸»çº¿ç¨‹
        }
    }
}
```

#### 2. åˆ›å»ºä¸‹è½½ä»»åŠ¡

**åŸºç¡€ä¸‹è½½ï¼š**
```kotlin
val task = DownloadManager.download("https://example.com/file.apk")
    .path(getExternalFilesDir(null)?.absolutePath ?: "")
    .fileName("app.apk")
    .start()
```

**å¸¦ä¼˜å…ˆçº§çš„ä¸‹è½½ï¼š**
```kotlin
// é«˜ä¼˜å…ˆçº§ä¸‹è½½ï¼ˆç”¨æˆ·ä¸»åŠ¨ä¸‹è½½ï¼‰
val task = DownloadManager.downloadWithPriority(url, DownloadPriority.HIGH)
    .path(downloadPath)
    .fileName("important.apk")
    .start()

// ç´§æ€¥ä¸‹è½½
val urgentTask = DownloadManager.downloadUrgent(url)
    .path(downloadPath)
    .fileName("critical.apk")
    .start()

// åå°ä¸‹è½½
val backgroundTask = DownloadManager.downloadBackground(url)
    .path(downloadPath)
    .fileName("background.apk")
    .start()
```

**å¸¦è‡ªå®šä¹‰è¯·æ±‚å¤´çš„ä¸‹è½½ï¼š**
```kotlin
val task = DownloadManager.download(url)
    .path(downloadPath)
    .fileName("app.apk")
    .headers(mapOf(
        "Authorization" to "Bearer token",
        "User-Agent" to "MyApp/1.0"
    ))
    .start()
```

#### 3. ä»»åŠ¡ç®¡ç†

```kotlin
// æš‚åœä»»åŠ¡
DownloadManager.pause(taskId)

// æ¢å¤ä»»åŠ¡
DownloadManager.resume(taskId)

// å–æ¶ˆä»»åŠ¡
DownloadManager.cancel(taskId)

// åˆ é™¤ä»»åŠ¡
DownloadManager.deleteTask(taskId, deleteFile = true)

// æ‰¹é‡æ“ä½œ
DownloadManager.pauseAll()
DownloadManager.resumeAll()
DownloadManager.cancelAll()
```

#### 4. æŸ¥è¯¢ä»»åŠ¡

```kotlin
// è·å–æ‰€æœ‰ä»»åŠ¡
val allTasks = DownloadManager.getAllTasks()

// è·å–ç‰¹å®šä»»åŠ¡
val task = DownloadManager.getTask(taskId)

// è·å–æ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡
val runningTasks = DownloadManager.getRunningTasks()

// æŒ‰ä¼˜å…ˆçº§æŸ¥è¯¢
val urgentTasks = DownloadManager.getUrgentTasks()
val normalTasks = DownloadManager.getNormalTasks()
val backgroundTasks = DownloadManager.getBackgroundTasks()
```

### ğŸ“± å“åº”å¼ç›‘å¬

#### Flowç›‘å¬å™¨ä½¿ç”¨

```kotlin
class MainActivity : AppCompatActivity() {
    
    private val flowListener = DownloadManager.flowListener
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // ç»‘å®šç”Ÿå‘½å‘¨æœŸç›‘å¬
        bindFlowListener()
    }
    
    private fun bindFlowListener() {
        flowListener.bindToLifecycle(
            lifecycleOwner = this,
            onTaskProgress = { task, progress, speed ->
                // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                updateProgress(task.id, progress, speed)
            },
            onTaskComplete = { task, file ->
                // ä¸‹è½½å®Œæˆ
                showDownloadComplete(task, file)
            },
            onTaskError = { task, error ->
                // ä¸‹è½½å¤±è´¥
                showDownloadError(task, error)
            },
            onTaskPaused = { task ->
                // ä»»åŠ¡æš‚åœ
                updateTaskStatus(task)
            },
            onTaskResumed = { task ->
                // ä»»åŠ¡æ¢å¤
                updateTaskStatus(task)
            },
            onTaskCancelled = { task ->
                // ä»»åŠ¡å–æ¶ˆ
                updateTaskStatus(task)
            }
        )
    }
}
```

#### æ‰‹åŠ¨ç›‘å¬ç‰¹å®šä»»åŠ¡

```kotlin
// ç›‘å¬ç‰¹å®šä»»åŠ¡çŠ¶æ€
flowListener.observeTaskStatus(taskId, lifecycleScope) { task ->
    task?.let { updateUI(it) }
}

// ç›‘å¬ç‰¹å®šä»»åŠ¡è¿›åº¦
flowListener.observeTaskProgress(taskId, lifecycleScope) { progress, speed ->
    updateProgressBar(progress)
    updateSpeedText(speed)
}
```

#### ç›‘å¬ä»»åŠ¡åˆ—è¡¨

```kotlin
// ç›‘å¬æ‰€æœ‰ä»»åŠ¡
flowListener.observeAllTasks().collect { tasks ->
    updateTaskList(tasks)
}

// ç›‘å¬æ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡
flowListener.observeRunningTasks().collect { tasks ->
    updateDownloadingList(tasks)
}

// ç›‘å¬å·²å®Œæˆçš„ä»»åŠ¡
flowListener.observeCompletedTasks().collect { tasks ->
    updateCompletedList(tasks)
}
```

### ğŸ¯ é«˜çº§åŠŸèƒ½

#### å­˜å‚¨ç®¡ç†

```kotlin
// æ£€æŸ¥å­˜å‚¨ç©ºé—´
val storageInfo = DownloadManager.getStorageInfo()
val isLowStorage = DownloadManager.isLowStorage()

// è·å–æ¨èä¸‹è½½è·¯å¾„
val recommendedPath = DownloadManager.getRecommendedPath()

// æ£€æŸ¥è·¯å¾„æ˜¯å¦å…è®¸
val isPathAllowed = DownloadManager.isPathAllowed("/path/to/download")
```

#### ç¼“å­˜ç®¡ç†

```kotlin
// è·å–ç¼“å­˜ç»Ÿè®¡
val cacheStats = DownloadManager.getCacheStats()

// è·å–çƒ­ä»»åŠ¡ï¼ˆæœ€è¿‘è®¿é—®ï¼‰
val hotTasks = DownloadManager.getHotTasks()

// è·å–å†·ä»»åŠ¡ï¼ˆè¾ƒå°‘è®¿é—®ï¼‰
val coldTasks = DownloadManager.getColdTasks()
```

#### ä¿ç•™ç­–ç•¥

```kotlin
// æ‰§è¡Œæ¸…ç†ç­–ç•¥
DownloadManager.executeRetentionPolicy()

// è·å–ä¿ç•™ç»Ÿè®¡
val retentionStats = DownloadManager.getRetentionStats()

// æ‰‹åŠ¨æ¸…ç†å·²å®Œæˆä»»åŠ¡
DownloadManager.cleanCompleted(
    deleteFiles = false,
    beforeTime = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000, // 7å¤©å‰
    limit = 50
)
```

### ğŸ”§ é…ç½®é€‰é¡¹

#### DownloadConfig é…ç½®

```kotlin
DownloadManager.config {
    // å¹¶å‘æ§åˆ¶
    maxConcurrentTasks = 3
    
    // è¶…æ—¶è®¾ç½®
    connectTimeoutSec = 60
    readTimeoutSec = 60
    writeTimeoutSec = 60
    
    // ç½‘ç»œæ§åˆ¶
    allowMetered = true
    
    // å›è°ƒçº¿ç¨‹
    callbackOnMain = true
    
    // æ–‡ä»¶æ ¡éªŒï¼ˆå¯é€‰ï¼‰
    checksum = Checksum(
        type = Checksum.Type.MD5,
        value = "expected_md5_hash",
        onFail = Checksum.OnFail.Retry
    )
    
    // ä¿ç•™ç­–ç•¥
    retention = Retention(
        keepDays = 30,                    // ä¿ç•™30å¤©
        keepLatestCompleted = 100         // æœ€å¤šä¿ç•™100ä¸ªå·²å®Œæˆä»»åŠ¡
    )
}
```

#### ä¼˜å…ˆçº§è¯´æ˜

```kotlin
enum class DownloadPriority(val value: Int) {
    LOW(0),      // åå°ä¸‹è½½ - ä½ä¼˜å…ˆçº§
    NORMAL(1),   // æ™®é€šä¸‹è½½ - é»˜è®¤ä¼˜å…ˆçº§
    HIGH(2),     // ç”¨æˆ·ä¸»åŠ¨ä¸‹è½½ - é«˜ä¼˜å…ˆçº§
    URGENT(3)    // ç³»ç»Ÿå…³é”®ä¸‹è½½ - æœ€é«˜ä¼˜å…ˆçº§
}
```

### ğŸ“‹ æƒé™é…ç½®

åœ¨ `AndroidManifest.xml` ä¸­æ·»åŠ å¿…è¦æƒé™ï¼š

```xml
<!-- ç½‘ç»œæƒé™ -->
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

<!-- å­˜å‚¨æƒé™ -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

<!-- Android 11+ å­˜å‚¨æƒé™ -->
<uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />
```

### ğŸ¨ UIé›†æˆå»ºè®®

#### RecyclerViewé€‚é…å™¨ç¤ºä¾‹

```kotlin
class DownloadTaskAdapter : RecyclerView.Adapter<DownloadTaskViewHolder>() {
    
    private val tasks = mutableListOf<DownloadTask>()
    private val flowListener = DownloadManager.flowListener
    
    fun bindToLifecycle(lifecycleOwner: LifecycleOwner) {
        flowListener.bindToLifecycle(
            lifecycleOwner = lifecycleOwner,
            onTaskProgress = { task, progress, speed ->
                updateTaskProgress(task.id, progress, speed)
            },
            onTaskComplete = { task, file ->
                updateTaskStatus(task)
            },
            onTaskError = { task, error ->
                updateTaskStatus(task)
            }
        )
    }
    
    private fun updateTaskProgress(taskId: String, progress: Int, speed: Long) {
        val index = tasks.indexOfFirst { it.id == taskId }
        if (index >= 0) {
            tasks[index] = tasks[index].copy(progress = progress, speed = speed)
            notifyItemChanged(index)
        }
    }
    
    private fun updateTaskStatus(task: DownloadTask) {
        val index = tasks.indexOfFirst { it.id == task.id }
        if (index >= 0) {
            tasks[index] = task
            notifyItemChanged(index)
        }
    }
}
```

## ğŸ“± ç›‘å¬åˆ—è¡¨åˆ·æ–°å¤„ç†å»ºè®®

åŸºäºé¡¹ç›®ä¸­çš„å®é™…ä½¿ç”¨ç»éªŒï¼Œä»¥ä¸‹æ˜¯ç›‘å¬åˆ—è¡¨åˆ·æ–°çš„æœ€ä½³å®è·µï¼š

### ğŸ¯ æ ¸å¿ƒåŸåˆ™

1. **ç”Ÿå‘½å‘¨æœŸç»‘å®š**ï¼šå§‹ç»ˆä½¿ç”¨ `bindToLifecycle()` ç¡®ä¿ç›‘å¬å™¨ä¸Activity/Fragmentç”Ÿå‘½å‘¨æœŸç»‘å®š
2. **é˜²æŠ–æœºåˆ¶**ï¼šå¯¹é¢‘ç¹çš„è¿›åº¦æ›´æ–°è¿›è¡Œé˜²æŠ–å¤„ç†ï¼Œé¿å…UIå¡é¡¿
3. **çŠ¶æ€åŒæ­¥**ï¼šä¿æŒæœ¬åœ°æ•°æ®ä¸ä¸‹è½½ä»»åŠ¡çŠ¶æ€åŒæ­¥
4. **åˆ†ç»„ç®¡ç†**ï¼šå°†ä»»åŠ¡æŒ‰çŠ¶æ€åˆ†ç»„ï¼ˆä¸‹è½½ä¸­ã€å·²å®Œæˆã€å¤±è´¥ç­‰ï¼‰

### ğŸ”„ åˆ—è¡¨åˆ·æ–°ç­–ç•¥

#### 1. å…¨é‡åˆ·æ–° vs å¢é‡æ›´æ–°

**å…¨é‡åˆ·æ–°åœºæ™¯ï¼š**
- ä»»åŠ¡çŠ¶æ€å‘ç”Ÿè·¨ç»„å˜åŒ–ï¼ˆå¦‚ä»ä¸‹è½½ä¸­å˜ä¸ºå·²å®Œæˆï¼‰
- ä»»åŠ¡æ•°é‡å˜åŒ–ï¼ˆæ–°å¢ã€åˆ é™¤ä»»åŠ¡ï¼‰
- é¡µé¢é¦–æ¬¡åŠ è½½

**å¢é‡æ›´æ–°åœºæ™¯ï¼š**
- ä»»åŠ¡è¿›åº¦å˜åŒ–
- ä»»åŠ¡çŠ¶æ€åœ¨åŒä¸€ç»„å†…å˜åŒ–ï¼ˆå¦‚ä»ç­‰å¾…å˜ä¸ºä¸‹è½½ä¸­ï¼‰

#### 2. é˜²æŠ–å¤„ç†

```kotlin
class DownloadListManager {
    
    // è¿›åº¦æ›´æ–°é˜²æŠ–
    private val lastProgressUpdateTimeMap = mutableMapOf<String, Long>()
    private val progressUpdateInterval = 300L // 300msé˜²æŠ–é—´éš”
    
    private fun updateTaskProgress(taskId: String, progress: Int, speed: Long) {
        val now = System.currentTimeMillis()
        val lastUpdateTime = lastProgressUpdateTimeMap[taskId] ?: 0L
        
        if (now - lastUpdateTime < progressUpdateInterval) {
            return // è·³è¿‡æ­¤æ¬¡æ›´æ–°
        }
        
        lastProgressUpdateTimeMap[taskId] = now
        // æ‰§è¡Œå®é™…çš„UIæ›´æ–°
        performProgressUpdate(taskId, progress, speed)
    }
}
```

#### 3. çŠ¶æ€åˆ†ç»„ç®¡ç†

```kotlin
class TaskListManager {
    
    private val downloading = mutableListOf<DownloadTask>()
    private val completed = mutableListOf<DownloadTask>()
    private val failed = mutableListOf<DownloadTask>()
    
    fun updateTask(task: DownloadTask) {
        val shouldBeInDownloading = task.status in listOf(
            DownloadStatus.DOWNLOADING,
            DownloadStatus.PAUSED,
            DownloadStatus.PENDING,
            DownloadStatus.WAITING
        )
        val shouldBeInCompleted = task.status == DownloadStatus.COMPLETED
        val shouldBeInFailed = task.status == DownloadStatus.FAILED
        
        val crossGroup = (downloading.contains(task) && shouldBeInCompleted) ||
                        (completed.contains(task) && shouldBeInDownloading)
        
        if (crossGroup) {
            // è·¨ç»„å˜åŒ–ï¼Œéœ€è¦å…¨é‡åˆ·æ–°
            refreshAllLists()
        } else {
            // åŒç»„å†…å˜åŒ–ï¼Œå¢é‡æ›´æ–°
            updateSingleTask(task)
        }
    }
    
    private fun updateSingleTask(task: DownloadTask) {
        when {
            downloading.any { it.id == task.id } -> {
                val index = downloading.indexOfFirst { it.id == task.id }
                if (index >= 0) {
                    downloading[index] = task
                    downloadingAdapter.notifyItemChanged(index)
                }
            }
            completed.any { it.id == task.id } -> {
                val index = completed.indexOfFirst { it.id == task.id }
                if (index >= 0) {
                    completed[index] = task
                    completedAdapter.notifyItemChanged(index)
                }
            }
            // ... å…¶ä»–åˆ†ç»„
        }
    }
}
```

### ğŸ¨ UIæ›´æ–°æœ€ä½³å®è·µ

#### 1. æŒ‰é’®çŠ¶æ€ç®¡ç†

```kotlin
private fun bindButtonUI(task: DownloadTask) {
    when (task.status) {
        DownloadStatus.DOWNLOADING -> {
            button.text = "${task.progress}%"
            button.setProgress(task.progress)
            button.isEnabled = true
        }
        DownloadStatus.PAUSED -> {
            button.text = "ç»§ç»­"
            button.setProgress(task.progress)
            button.isEnabled = true
        }
        DownloadStatus.WAITING, DownloadStatus.PENDING -> {
            button.text = "ç­‰å¾…ä¸­"
            button.isEnabled = true
        }
        DownloadStatus.COMPLETED -> {
            button.text = "å®‰è£…"
            button.setProgress(100)
            button.isEnabled = true
        }
        DownloadStatus.FAILED -> {
            button.text = "é‡è¯•"
            button.isEnabled = true
        }
        else -> {
            button.text = "ä¸‹è½½"
            button.setProgress(0)
            button.isEnabled = true
        }
    }
}
```

#### 2. è¿›åº¦æ˜¾ç¤ºä¼˜åŒ–

```kotlin
private fun updateProgressDisplay(task: DownloadTask, progress: Int, speed: Long) {
    // æ›´æ–°è¿›åº¦æ¡
    progressBar.progress = progress
    
    // æ›´æ–°é€Ÿåº¦æ˜¾ç¤ºï¼ˆæ ¼å¼åŒ–ï¼‰
    speedText.text = formatSpeed(speed)
    
    // æ›´æ–°å‰©ä½™æ—¶é—´
    val remainingTime = calculateRemainingTime(task.totalSize, task.currentSize, speed)
    timeText.text = formatTime(remainingTime)
}

private fun formatSpeed(bytesPerSecond: Long): String {
    return when {
        bytesPerSecond >= 1024 * 1024 -> "${bytesPerSecond / (1024 * 1024)} MB/s"
        bytesPerSecond >= 1024 -> "${bytesPerSecond / 1024} KB/s"
        else -> "$bytesPerSecond B/s"
    }
}
```

#### 3. é”™è¯¯å¤„ç†

```kotlin
private fun handleDownloadError(task: DownloadTask, error: DownloadError) {
    when (error) {
        DownloadError.NetworkError -> {
            showErrorDialog("ç½‘ç»œé”™è¯¯", "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•")
        }
        DownloadError.StorageError -> {
            showErrorDialog("å­˜å‚¨ç©ºé—´ä¸è¶³", "è¯·æ¸…ç†å­˜å‚¨ç©ºé—´åé‡è¯•")
        }
        DownloadError.FileError -> {
            showErrorDialog("æ–‡ä»¶é”™è¯¯", "æ–‡ä»¶å¯èƒ½å·²æŸåï¼Œè¯·é‡æ–°ä¸‹è½½")
        }
        else -> {
            showErrorDialog("ä¸‹è½½å¤±è´¥", "æœªçŸ¥é”™è¯¯ï¼Œè¯·é‡è¯•")
        }
    }
}
```

### ğŸš€ æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### 1. å†…å­˜ç®¡ç†

```kotlin
class DownloadActivity : AppCompatActivity() {
    
    private var flowListener: FlowDownloadListener? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // å»¶è¿Ÿåˆå§‹åŒ–ç›‘å¬å™¨
        flowListener = DownloadManager.flowListener
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // Flowç›‘å¬å™¨ä¼šè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼Œæ— éœ€æ‰‹åŠ¨æ¸…ç†
        flowListener = null
    }
}
```

#### 2. åˆ—è¡¨ä¼˜åŒ–

```kotlin
// ä½¿ç”¨ DiffUtil ä¼˜åŒ–åˆ—è¡¨æ›´æ–°
class DownloadTaskDiffCallback : DiffUtil.Callback() {
    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return oldList[oldItemPosition].id == newList[newItemPosition].id
    }
    
    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        val oldTask = oldList[oldItemPosition]
        val newTask = newList[newItemPosition]
        return oldTask.status == newTask.status && 
               oldTask.progress == newTask.progress &&
               oldTask.speed == newTask.speed
    }
}
```

#### 3. ç½‘ç»œçŠ¶æ€ç›‘å¬

**é‡è¦è¯´æ˜**ï¼šä¸‹è½½åº“ä¸å†å†…éƒ¨ç›‘å¬ç½‘ç»œçŠ¶æ€ï¼Œå°†ç½‘ç»œç›‘å¬çš„è´£ä»»äº¤ç»™æ¥å…¥è€…ï¼Œè¿™æ ·æ›´å®‰å…¨ã€æ›´çµæ´»ã€‚

```kotlin
// æ–¹å¼1ï¼šä½¿ç”¨ConnectivityManager.NetworkCallbackï¼ˆæ¨èï¼‰
private fun setupNetworkListener() {
    val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            // ç½‘ç»œæ¢å¤ï¼Œé€šçŸ¥ä¸‹è½½ç®¡ç†å™¨æ¢å¤ç½‘ç»œå¼‚å¸¸æš‚åœçš„ä»»åŠ¡
            DownloadManager.onNetworkRestored()
        }
        
        override fun onLost(network: Network) {
            // ç½‘ç»œæ–­å¼€ï¼Œåªæš‚åœæ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡ï¼Œä¸å½±å“ç”¨æˆ·æ‰‹åŠ¨æš‚åœçš„ä»»åŠ¡
            DownloadManager.pauseAllForNetworkError()
        }
    }
    
    connectivityManager.registerDefaultNetworkCallback(networkCallback)
}

// æ–¹å¼2ï¼šä½¿ç”¨å¹¿æ’­æ¥æ”¶å™¨
class NetworkReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        if (intent?.action == ConnectivityManager.CONNECTIVITY_ACTION) {
            val connectivityManager = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val network = connectivityManager.activeNetwork
            val capabilities = connectivityManager.getNetworkCapabilities(network)
            val isConnected = capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
            
            if (isConnected) {
                // ç½‘ç»œæ¢å¤ï¼Œé€šçŸ¥ä¸‹è½½ç®¡ç†å™¨
                DownloadManager.onNetworkRestored()
            }
        }
    }
}

// æ–¹å¼3ï¼šä½¿ç”¨ç¬¬ä¸‰æ–¹ç½‘ç»œç›‘å¬åº“
NetStateReceiver(
    onNetConnected = { isWifi ->
        // ç½‘ç»œæ¢å¤
        DownloadManager.onNetworkRestored()
    },
    onNetDisConnected = {
        // ç½‘ç»œæ–­å¼€ï¼Œåªæš‚åœæ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡ï¼Œä¸å½±å“ç”¨æˆ·æ‰‹åŠ¨æš‚åœçš„ä»»åŠ¡
        DownloadManager.pauseAllForNetworkError()
    }
).register(this)
```

**ç½‘ç»œçŠ¶æ€æ£€æŸ¥API**ï¼š

```kotlin
// æ£€æŸ¥ç½‘ç»œæ˜¯å¦å¯ç”¨
val isNetworkAvailable = DownloadManager.isNetworkAvailable()

// æ£€æŸ¥æ˜¯å¦è¿æ¥åˆ°WiFi
val isWifiAvailable = DownloadManager.isWifiAvailable()

// æ£€æŸ¥æ˜¯å¦è¿æ¥åˆ°ç§»åŠ¨ç½‘ç»œ
val isCellularAvailable = DownloadManager.isCellularAvailable()

// è·å–å½“å‰ç½‘ç»œç±»å‹
val networkType = DownloadManager.getNetworkType() // "WiFi", "Cellular", "Ethernet", "Unknown", "No Network"

// æ£€æŸ¥æ˜¯å¦ä¸ºè®¡è´¹ç½‘ç»œ
val isMetered = DownloadManager.isMeteredNetwork()
```

**ç½‘ç»œæ¢å¤APIè¯´æ˜**ï¼š

```kotlin
// æ£€æŸ¥æ˜¯å¦æœ‰å› ç½‘ç»œå¼‚å¸¸æš‚åœçš„ä»»åŠ¡
val count = DownloadManager.getNetworkPausedTaskCount()

// è·å–å› ç½‘ç»œå¼‚å¸¸æš‚åœçš„ä»»åŠ¡åˆ—è¡¨
val pausedTasks = DownloadManager.getNetworkPausedTasks()

// æ‰‹åŠ¨è§¦å‘ç½‘ç»œæ¢å¤æ£€æŸ¥
DownloadManager.onNetworkRestored()
```

### âš ï¸ é‡è¦ï¼šæš‚åœåŸå› çš„åŒºåˆ«

ä¸‹è½½ç®¡ç†å™¨æ”¯æŒå¤šç§æš‚åœåŸå› ï¼Œæ­£ç¡®åŒºåˆ†å®ƒä»¬å¾ˆé‡è¦ï¼š

```kotlin
// 1. ç”¨æˆ·æ‰‹åŠ¨æš‚åœï¼ˆé»˜è®¤ï¼‰
DownloadManager.pause(taskId) // pauseReason = USER_MANUAL

// 2. ç½‘ç»œå¼‚å¸¸æš‚åœ
DownloadManager.pauseTask(taskId, PauseReason.NETWORK_ERROR)

// 3. å­˜å‚¨ç©ºé—´ä¸è¶³æš‚åœ
DownloadManager.pauseTask(taskId, PauseReason.STORAGE_FULL)

// 4. æ‰¹é‡æ“ä½œ
DownloadManager.pauseAll() // æ‰€æœ‰ä»»åŠ¡æ ‡è®°ä¸º USER_MANUAL
DownloadManager.pauseAll(PauseReason.NETWORK_ERROR) // æ‰€æœ‰ä»»åŠ¡æ ‡è®°ä¸º NETWORK_ERROR
DownloadManager.pauseAllForNetworkError() // åªæš‚åœæ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡ï¼Œæ ‡è®°ä¸º NETWORK_ERROR
```

**ç½‘ç»œæ¢å¤æ—¶çš„è¡Œä¸º**ï¼š
- `DownloadManager.onNetworkRestored()` åªä¼šæ¢å¤ `PauseReason.NETWORK_ERROR` çš„ä»»åŠ¡
- ç”¨æˆ·æ‰‹åŠ¨æš‚åœçš„ä»»åŠ¡ä¸ä¼šè¢«è‡ªåŠ¨æ¢å¤
- å­˜å‚¨ç©ºé—´ä¸è¶³æš‚åœçš„ä»»åŠ¡ä¸ä¼šè¢«ç½‘ç»œæ¢å¤å½±å“

## ğŸŒ ç½‘ç»œç›‘å¬æœ€ä½³å®è·µ

### ğŸ¯ è®¾è®¡åŸåˆ™

1. **èŒè´£åˆ†ç¦»**ï¼šä¸‹è½½åº“ä¸“æ³¨äºä¸‹è½½åŠŸèƒ½ï¼Œç½‘ç»œç›‘å¬ç”±åº”ç”¨å±‚è´Ÿè´£
2. **å®‰å…¨æ€§**ï¼šé¿å…ä¸‹è½½åº“å†…éƒ¨æ³¨å†Œå¹¿æ’­æ¥æ”¶å™¨ï¼Œå‡å°‘æƒé™éœ€æ±‚
3. **çµæ´»æ€§**ï¼šæ¥å…¥è€…å¯ä»¥æ ¹æ®ä¸šåŠ¡éœ€æ±‚è‡ªå®šä¹‰ç½‘ç»œç›‘å¬é€»è¾‘
4. **å¯æ§æ€§**ï¼šæ¥å…¥è€…å®Œå…¨æ§åˆ¶ä½•æ—¶æ¢å¤ç½‘ç»œå¼‚å¸¸æš‚åœçš„ä»»åŠ¡

### ğŸ”§ å®ç°æ–¹å¼å¯¹æ¯”

| æ–¹å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| NetworkCallback | å®æ—¶æ€§å¥½ï¼ŒAPIç°ä»£ | éœ€è¦API 21+ | ç°ä»£åº”ç”¨æ¨è |
| BroadcastReceiver | å…¼å®¹æ€§å¥½ | æ€§èƒ½è¾ƒå·®ï¼Œå·²åºŸå¼ƒ | å…¼å®¹è€ç‰ˆæœ¬ |
| ç¬¬ä¸‰æ–¹åº“ | åŠŸèƒ½ä¸°å¯Œ | å¢åŠ ä¾èµ– | å¤æ‚ä¸šåŠ¡éœ€æ±‚ |

### ğŸ“± å®Œæ•´ç¤ºä¾‹

```kotlin
class DownloadActivity : AppCompatActivity() {
    
    private var networkCallback: ConnectivityManager.NetworkCallback? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨
        DownloadManager.init(this)
        
        // è®¾ç½®ç½‘ç»œç›‘å¬
        setupNetworkListener()
        
        // ç»‘å®šä¸‹è½½ç›‘å¬
        bindDownloadListener()
    }
    
    private fun setupNetworkListener() {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        
        networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                runOnUiThread {
                    // ç½‘ç»œæ¢å¤ï¼Œæ£€æŸ¥å¹¶æ¢å¤ç½‘ç»œå¼‚å¸¸æš‚åœçš„ä»»åŠ¡
                    lifecycleScope.launch {
                        val pausedCount = DownloadManager.getNetworkPausedTaskCount()
                        if (pausedCount > 0) {
                            DownloadManager.onNetworkRestored()
                            showToast("ç½‘ç»œæ¢å¤ï¼Œå·²è‡ªåŠ¨æ¢å¤ $pausedCount ä¸ªä¸‹è½½ä»»åŠ¡")
                        }
                    }
                }
            }
            
            override fun onLost(network: Network) {
                runOnUiThread {
                    // ç½‘ç»œæ–­å¼€ï¼Œæš‚åœæ‰€æœ‰ä¸‹è½½ä»»åŠ¡
                    DownloadManager.pauseAll()
                    showToast("ç½‘ç»œæ–­å¼€ï¼Œå·²æš‚åœæ‰€æœ‰ä¸‹è½½ä»»åŠ¡")
                }
            }
            
            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {
                // ç½‘ç»œèƒ½åŠ›å˜åŒ–ï¼Œå¯ä»¥æ ¹æ®ç½‘ç»œç±»å‹è°ƒæ•´ä¸‹è½½ç­–ç•¥
                val isWifi = networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
                val isCellular = networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)
                
                if (isWifi) {
                    // WiFiç½‘ç»œï¼Œå¯ä»¥å¢åŠ å¹¶å‘æ•°
                    DownloadManager.config {
                        maxConcurrentTasks = 5
                    }
                } else if (isCellular) {
                    // ç§»åŠ¨ç½‘ç»œï¼Œå‡å°‘å¹¶å‘æ•°
                    DownloadManager.config {
                        maxConcurrentTasks = 2
                    }
                }
            }
        }
        
        connectivityManager.registerDefaultNetworkCallback(networkCallback!!)
    }
    
    private fun bindDownloadListener() {
        DownloadManager.flowListener.bindToLifecycle(
            lifecycleOwner = this,
            onTaskProgress = { task, progress, speed ->
                updateTaskProgress(task.id, progress, speed)
            },
            onTaskComplete = { task, file ->
                showToast("ä¸‹è½½å®Œæˆï¼š${task.fileName}")
            },
            onTaskError = { task, error ->
                when (error) {
                    DownloadError.NetworkError -> {
                        // ç½‘ç»œé”™è¯¯ï¼Œä»»åŠ¡ä¼šè‡ªåŠ¨æš‚åœï¼Œç­‰å¾…ç½‘ç»œæ¢å¤
                        showToast("ç½‘ç»œé”™è¯¯ï¼Œä»»åŠ¡å·²æš‚åœ")
                    }
                    else -> {
                        showToast("ä¸‹è½½å¤±è´¥ï¼š${task.fileName}")
                    }
                }
            }
        )
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // å–æ¶ˆç½‘ç»œç›‘å¬
        networkCallback?.let { callback ->
            val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }
}
```

### ğŸš€ é«˜çº§ç”¨æ³•

#### 1. æ™ºèƒ½ç½‘ç»œæ¢å¤

```kotlin
class SmartNetworkManager {
    
    private var lastNetworkLostTime = 0L
    private var networkLostCount = 0
    
    fun onNetworkRestored() {
        val now = System.currentTimeMillis()
        val timeSinceLastLost = now - lastNetworkLostTime
        
        // å¦‚æœç½‘ç»œé¢‘ç¹æ–­å¼€ï¼Œå»¶è¿Ÿæ¢å¤
        if (timeSinceLastLost < 5000) {
            networkLostCount++
            if (networkLostCount > 3) {
                // å»¶è¿Ÿ10ç§’æ¢å¤ï¼Œé¿å…é¢‘ç¹é‡è¯•
                Handler(Looper.getMainLooper()).postDelayed({
                    DownloadManager.onNetworkRestored()
                }, 10000)
                return
            }
        } else {
            networkLostCount = 0
        }
        
        // ç«‹å³æ¢å¤
        DownloadManager.onNetworkRestored()
    }
    
    fun onNetworkLost() {
        lastNetworkLostTime = System.currentTimeMillis()
        DownloadManager.pauseAll()
    }
}
```

#### 2. ç½‘ç»œç±»å‹æ„ŸçŸ¥

```kotlin
private fun handleNetworkCapabilitiesChanged(networkCapabilities: NetworkCapabilities) {
    val isWifi = networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    val isCellular = networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)
    val isEthernet = networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)
    
    when {
        isWifi -> {
            // WiFiç½‘ç»œï¼Œæœ€ä¼˜ä¸‹è½½ä½“éªŒ
            DownloadManager.config {
                maxConcurrentTasks = 5
                allowMetered = true
            }
        }
        isEthernet -> {
            // æœ‰çº¿ç½‘ç»œï¼Œç¨³å®šé«˜é€Ÿ
            DownloadManager.config {
                maxConcurrentTasks = 8
                allowMetered = true
            }
        }
        isCellular -> {
            // ç§»åŠ¨ç½‘ç»œï¼Œä¿å®ˆç­–ç•¥
            DownloadManager.config {
                maxConcurrentTasks = 2
                allowMetered = false // æ ¹æ®ç”¨æˆ·è®¾ç½®å†³å®š
            }
        }
    }
}

// æˆ–è€…ä½¿ç”¨DownloadManageræä¾›çš„ç½‘ç»œæ£€æŸ¥API
private fun adjustDownloadStrategy() {
    when {
        DownloadManager.isWifiAvailable() -> {
            // WiFiç½‘ç»œï¼Œæœ€ä¼˜ä¸‹è½½ä½“éªŒ
            DownloadManager.config {
                maxConcurrentTasks = 5
                allowMetered = true
            }
        }
        DownloadManager.isCellularAvailable() -> {
            // ç§»åŠ¨ç½‘ç»œï¼Œä¿å®ˆç­–ç•¥
            DownloadManager.config {
                maxConcurrentTasks = 2
                allowMetered = false
            }
        }
        !DownloadManager.isNetworkAvailable() -> {
            // æ— ç½‘ç»œï¼Œæš‚åœæ‰€æœ‰ä¸‹è½½
            DownloadManager.pauseAll()
        }
    }
}
```

### ğŸ“ æ€»ç»“

é€šè¿‡ä»¥ä¸Šæ¥å…¥æ–‡æ¡£å’Œæœ€ä½³å®è·µï¼Œä½ å¯ä»¥ï¼š

1. **å¿«é€Ÿé›†æˆ**ï¼šæŒ‰ç…§æ–‡æ¡£æ­¥éª¤å¿«é€Ÿé›†æˆä¸‹è½½ç®¡ç†å™¨
2. **é«˜æ•ˆç›‘å¬**ï¼šä½¿ç”¨Flowç›‘å¬å™¨å®ç°å“åº”å¼UIæ›´æ–°
3. **ä¼˜åŒ–æ€§èƒ½**ï¼šé€šè¿‡é˜²æŠ–ã€åˆ†ç»„ç®¡ç†ç­‰ç­–ç•¥ä¼˜åŒ–åˆ—è¡¨åˆ·æ–°æ€§èƒ½
4. **æå‡ä½“éªŒ**ï¼šé€šè¿‡åˆç†çš„çŠ¶æ€ç®¡ç†å’Œé”™è¯¯å¤„ç†æå‡ç”¨æˆ·ä½“éªŒ
5. **ç½‘ç»œä¼˜åŒ–**ï¼šé€šè¿‡è‡ªå®šä¹‰ç½‘ç»œç›‘å¬å®ç°æ™ºèƒ½çš„ç½‘ç»œæ¢å¤ç­–ç•¥

è¿™ä¸ªä¸‹è½½ç®¡ç†å™¨æä¾›äº†ä¼ä¸šçº§çš„åŠŸèƒ½ç‰¹æ€§ï¼Œæ”¯æŒå¤šçº¿ç¨‹åˆ†ç‰‡ä¸‹è½½ã€æ–­ç‚¹ç»­ä¼ ã€ä¼˜å…ˆçº§è°ƒåº¦ç­‰ï¼Œèƒ½å¤Ÿæ»¡è¶³å„ç§å¤æ‚çš„ä¸‹è½½åœºæ™¯éœ€æ±‚ã€‚åŒæ—¶ï¼Œé€šè¿‡å°†ç½‘ç»œç›‘å¬è´£ä»»äº¤ç»™æ¥å…¥è€…ï¼Œç¡®ä¿äº†æ›´å¥½çš„å®‰å…¨æ€§å’Œçµæ´»æ€§ã€‚
